{"version":3,"file":"body-streams.js","sourceRoot":"","sources":["../../src/server/body-streams.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IncomingMessage } from 'http'\nimport { Readable } from 'stream'\n\ntype BodyStream = ReadableStream<Uint8Array>\n\n/**\n * An interface that encapsulates body stream cloning\n * of an incoming request.\n */\nexport function getClonableBodyStream<T extends IncomingMessage>(\n  incomingMessage: T,\n  KUint8Array: typeof Uint8Array,\n  KTransformStream: typeof TransformStream\n) {\n  let bufferedBodyStream: BodyStream | null = null\n\n  return {\n    /**\n     * Replaces the original request body if necessary.\n     * This is done because once we read the body from the original request,\n     * we can't read it again.\n     */\n    finalize(): void {\n      if (bufferedBodyStream) {\n        replaceRequestBody(\n          incomingMessage,\n          bodyStreamToNodeStream(bufferedBodyStream)\n        )\n      }\n    },\n    /**\n     * Clones the body stream\n     * to pass into a middleware\n     */\n    cloneBodyStream(): BodyStream {\n      const originalStream =\n        bufferedBodyStream ??\n        requestToBodyStream(incomingMessage, KUint8Array, KTransformStream)\n      const [stream1, stream2] = originalStream.tee()\n      bufferedBodyStream = stream1\n      return stream2\n    },\n  }\n}\n\n/**\n * Creates a ReadableStream from a Node.js HTTP request\n */\nfunction requestToBodyStream(\n  request: IncomingMessage,\n  KUint8Array: typeof Uint8Array,\n  KTransformStream: typeof TransformStream\n): BodyStream {\n  const transform = new KTransformStream<Uint8Array, Uint8Array>({\n    start(controller) {\n      request.on('data', (chunk) =>\n        controller.enqueue(new KUint8Array([...new Uint8Array(chunk)]))\n      )\n      request.on('end', () => controller.terminate())\n      request.on('error', (err) => controller.error(err))\n    },\n  })\n\n  return transform.readable as unknown as ReadableStream<Uint8Array>\n}\n\nfunction bodyStreamToNodeStream(bodyStream: BodyStream): Readable {\n  const reader = bodyStream.getReader()\n  return Readable.from(\n    (async function* () {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          return\n        }\n        yield value\n      }\n    })()\n  )\n}\n\nfunction replaceRequestBody<T extends IncomingMessage>(\n  base: T,\n  stream: Readable\n): T {\n  for (const key in stream) {\n    let v = stream[key as keyof Readable] as any\n    if (typeof v === 'function') {\n      v = v.bind(stream)\n    }\n    base[key as keyof T] = v\n  }\n\n  return base\n}\n\n/**\n * Creates an async iterator from a ReadableStream that ensures that every\n * emitted chunk is a `Uint8Array`. If there is some invalid chunk it will\n * throw.\n */\nexport async function* consumeUint8ArrayReadableStream(body?: ReadableStream) {\n  const reader = body?.getReader()\n  if (reader) {\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) {\n        return\n      }\n\n      if (value?.constructor?.name !== 'Uint8Array') {\n        throw new TypeError('This ReadableStream did not return bytes.')\n      }\n\n      yield value as Uint8Array\n    }\n  }\n}\n"]}