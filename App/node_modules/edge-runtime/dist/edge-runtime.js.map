{"version":3,"file":"edge-runtime.js","sourceRoot":"","sources":["../src/edge-runtime.ts"],"names":[],"mappings":";;;AAEA,yCAAyC;AAWzC;;;GAGG;AACH,IAAI,0BAA8C,CAAA;AAClD,IAAI,yBAAyC,CAAA;AAE7C;;;;GAIG;AACH,MAAa,WAEX,SAAQ,WAAS;IAGjB,YAAY,OAAoB;QAC9B,KAAK,CAAC;YACJ,GAAG,OAAO;YACV,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE;;gBAClB,OAAO,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,wDAAG,OAAO,CAAC,mCAAK,OAA2B,CAAA;YACnE,CAAC;SACF,CAAC,CAAA;QAEF,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,gCAAgC,EAAE;YACpE,GAAG,EAAE,kCAAkC;YACvC,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAA;QACF,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,qBAAqB,EAAE;YACjD,GAAG,EAAE,GAAG,EAAE,CAAC,0BAA0B;YACrC,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAA;QAEF,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,mBAAmB,EAAE;YACvD,GAAG,EAAE,iCAAiC;YACtC,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAA;QACF,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;YAC7C,GAAG,EAAE,GAAG,EAAE,CAAC,yBAAyB;YACpC,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAA;QAEF,IAAI,CAAC,QAAQ,CAAO,2BAA2B,EAAE,CAAC,CAAA;QAClD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAgB,oBAAoB,EAAE,CAAC,CAAA;QACzE,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,EAAE;YACxB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;SACnC;IACH,CAAC;CACF;AAzCD,kCAyCC;AAED;;;;GAIG;AACH,SAAS,kCAAkC,CAAC,QAA4B;IACtE,IAAI,CAAC,0BAA0B,EAAE;QAC/B,OAAO,CAAC,EAAE,CACR,oBAAoB,EACpB,SAAS,uBAAuB,CAAC,MAAM,EAAE,OAAO;YAC9C,0BAA0B,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAC7C,OAAO,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAC7B,CAAA;QACH,CAAC,CACF,CAAA;KACF;IACD,0BAA0B,GAAG,QAAQ,CAAA;AACvC,CAAC;AAED,SAAS,iCAAiC,CAAC,QAAwB;IACjE,IAAI,CAAC,yBAAyB,EAAE;QAC9B,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,SAAS,mBAAmB,CAAC,KAAK;YAChE,yBAAyB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAA;QAChE,CAAC,CAAC,CAAA;KACH;IACD,yBAAyB,GAAG,QAAQ,CAAA;AACtC,CAAC;AAED;;;;;;GAMG;AACH,SAAS,2BAA2B;IAClC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCN,CAAA;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,oBAAoB;IAC3B,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAoCJ,CAAA;AACL,CAAC","sourcesContent":["import type { DispatchFetch, ErrorHandler, RejectionHandler } from './types'\nimport type { EdgeVMOptions, EdgeContext } from '@edge-runtime/vm'\nimport { EdgeVM } from '@edge-runtime/vm'\n\ninterface Options<T extends EdgeContext> extends EdgeVMOptions<T> {\n  /**\n   * Code to be evaluated as the VM for the Runtime is created. This is handy\n   * to run code directly instead of first creating the runtime and then\n   * evaluating.\n   */\n  initialCode?: string\n}\n\n/**\n * Store handlers that the user defined from code so that we can invoke them\n * from the Node.js realm.\n */\nlet unhandledRejectionHandlers: RejectionHandler[]\nlet uncaughtExceptionHandlers: ErrorHandler[]\n\n/**\n * An EdgeVM that also allows to add and remove event listeners for unhandled\n * rejections and FetchEvent. It also allows to dispatch fetch events which\n * enables it to work behind a server.\n */\nexport class EdgeRuntime<\n  T extends EdgeContext = EdgeContext\n> extends EdgeVM<T> {\n  public readonly dispatchFetch: DispatchFetch\n\n  constructor(options?: Options<T>) {\n    super({\n      ...options,\n      extend: (context) => {\n        return options?.extend?.(context) ?? (context as EdgeContext & T)\n      },\n    })\n\n    Object.defineProperty(this.context, '__onUnhandledRejectionHandlers', {\n      set: registerUnhandledRejectionHandlers,\n      configurable: false,\n      enumerable: false,\n    })\n    Object.defineProperty(this, '__rejectionHandlers', {\n      get: () => unhandledRejectionHandlers,\n      configurable: false,\n      enumerable: false,\n    })\n\n    Object.defineProperty(this.context, '__onErrorHandlers', {\n      set: registerUncaughtExceptionHandlers,\n      configurable: false,\n      enumerable: false,\n    })\n    Object.defineProperty(this, '__errorHandlers', {\n      get: () => uncaughtExceptionHandlers,\n      configurable: false,\n      enumerable: false,\n    })\n\n    this.evaluate<void>(getDefineEventListenersCode())\n    this.dispatchFetch = this.evaluate<DispatchFetch>(getDispatchFetchCode())\n    if (options?.initialCode) {\n      this.evaluate(options.initialCode)\n    }\n  }\n}\n\n/**\n * Register system-level handlers to make sure that we report to the user\n * whenever there is an unhandled rejection or exception before the process crashes.\n * Do it on demand so we don't swallow rejections/errors for no reason.\n */\nfunction registerUnhandledRejectionHandlers(handlers: RejectionHandler[]) {\n  if (!unhandledRejectionHandlers) {\n    process.on(\n      'unhandledRejection',\n      function invokeRejectionHandlers(reason, promise) {\n        unhandledRejectionHandlers.forEach((handler) =>\n          handler({ reason, promise })\n        )\n      }\n    )\n  }\n  unhandledRejectionHandlers = handlers\n}\n\nfunction registerUncaughtExceptionHandlers(handlers: ErrorHandler[]) {\n  if (!uncaughtExceptionHandlers) {\n    process.on('uncaughtException', function invokeErrorHandlers(error) {\n      uncaughtExceptionHandlers.forEach((handler) => handler(error))\n    })\n  }\n  uncaughtExceptionHandlers = handlers\n}\n\n/**\n * Generates polyfills for addEventListener and removeEventListener. It keeps\n * all listeners in hidden property __listeners. It will also call a hook\n * `__onUnhandledRejectionHandler` and `__onErrorHandler` when unhandled rejection\n * events are added or removed and prevent from having more than one FetchEvent\n * handler.\n */\nfunction getDefineEventListenersCode() {\n  return `\n    Object.defineProperty(self, '__listeners', {\n      configurable: false,\n      enumerable: false,\n      value: {},\n      writable: true,\n    })\n\n    function __conditionallyUpdatesHandlerList(eventType) {\n      if (eventType === 'unhandledrejection') {\n        self.__onUnhandledRejectionHandlers = self.__listeners[eventType];\n      } else if (eventType === 'error') {\n        self.__onErrorHandlers = self.__listeners[eventType];\n      }\n    }\n\n    function addEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (eventType === 'fetch' && self.__listeners.fetch) {\n        throw new TypeError('You can register just one \"fetch\" event listener');\n      }\n\n      self.__listeners[eventType] = self.__listeners[eventType] || [];\n      self.__listeners[eventType].push(handler);\n      __conditionallyUpdatesHandlerList(eventType);\n    }\n\n    function removeEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (self.__listeners[eventType]) {\n        self.__listeners[eventType] = self.__listeners[eventType].filter(item => {\n          return item !== handler;\n        });\n\n        if (self.__listeners[eventType].length === 0) {\n          delete self.__listeners[eventType];\n        }\n      }\n      __conditionallyUpdatesHandlerList(eventType);\n    }\n  `\n}\n\n/**\n * Generates the code to dispatch a FetchEvent invoking the handlers defined\n * for such events. In case there is no event handler defined it will throw\n * an error.\n */\nfunction getDispatchFetchCode() {\n  return `(async function dispatchFetch(input, init) {\n    const request = new Request(input, init);\n    const event = new FetchEvent(request);\n    if (!self.__listeners.fetch) {\n      throw new Error(\"No fetch event listeners found\");\n    }\n\n    const getResponse = ({ response, error }) => {\n     if (error || !response || !(response instanceof Response)) {\n        console.error(error ? error.toString() : 'The event listener did not respond')\n        response = new Response(null, {\n          statusText: 'Internal Server Error',\n          status: 500\n        })\n      }\n\n      response.waitUntil = () => Promise.all(event.awaiting);\n\n      if (response.status < 300 || response.status >= 400 ) {\n        response.headers.delete('content-encoding');\n        response.headers.delete('transform-encoding');\n        response.headers.delete('content-length');\n      }\n\n      return response;\n    }\n\n    try {\n      await self.__listeners.fetch[0].call(event, event)\n    } catch (error) {\n      return getResponse({ error })\n    }\n\n    return Promise.resolve(event.response)\n      .then(response => getResponse({ response }))\n      .catch(error => getResponse({ error }))\n  })`\n}\n"]}