{"version":3,"file":"vm.js","sourceRoot":"","sources":["../src/vm.ts"],"names":[],"mappings":";;;AAEA,2BAAgD;AAChD,uCAAyC;AACzC,2CAAsC;AAoBtC;;;;GAIG;AACH,MAAa,EAAE;IAKb,YAAY,UAAwB,EAAE;;QACpC,MAAM,OAAO,GAAG,IAAA,kBAAa,EAC3B,EAAE,EACF;YACE,IAAI,EAAE,cAAc;YACpB,cAAc,EAAE,MAAA,OAAO,CAAC,cAAc,mCAAI;gBACxC,OAAO,EAAE,KAAK;gBACd,IAAI,EAAE,IAAI;aACX;SACF,CACW,CAAA;QAEd,IAAI,CAAC,YAAY,GAAG,MAAA,OAAO,CAAC,YAAY,mCAAI,IAAI,GAAG,EAAE,CAAA;QACrD,IAAI,CAAC,OAAO,GAAG,MAAA,MAAA,OAAO,CAAC,MAAM,wDAAG,OAAO,CAAC,mCAAI,OAAwB,CAAA;QACpE,IAAI,CAAC,SAAS,GAAG,IAAA,uBAAa,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,CAAC,CAAA;IACjE,CAAC;IAED;;OAEG;IACH,QAAQ,CAAU,IAAY;QAC5B,OAAO,IAAA,iBAAY,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAA;IACzC,CAAC;IAED;;;OAGG;IACH,OAAO,CAA6B,QAAgB;QAClD,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;IAC3C,CAAC;IAED;;;;OAIG;IACH,gBAAgB,CAA6B,QAAgB;QAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAI,QAAQ,CAAC,CAAA;QAC9C,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;YACvD,IAAI,CAAC,OAAO,CAAC,GAAgC,CAAC,GAAG,KAAK,CAAA;SACvD;IACH,CAAC;IAED;;;;OAIG;IACH,sBAAsB,CAAC,IAAY;QACjC,MAAM,IAAI,GAAG,IAAA,oBAAQ,EAAC,IAAI,CAAC,CAAA;QAC3B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAChC,IAAI,CAAC,MAAM,EAAE,CAAA;IACf,CAAC;CACF;AA3DD,gBA2DC","sourcesContent":["import type { CreateContextOptions } from 'vm'\nimport type { Dictionary } from './types'\nimport { createContext, runInContext } from 'vm'\nimport { createRequire } from './require'\nimport { tempFile } from './temp-file'\n\nexport interface VMOptions<T> {\n  /**\n   * Provide code generation options to the Node.js VM.\n   * If you don't provide any option, code generation will be disabled.\n   */\n  codeGeneration?: CreateContextOptions['codeGeneration']\n  /**\n   * Allows to extend the VMContext. Note that it must return a contextified\n   * object so ideally it should return the same reference it receives.\n   */\n  extend?: (context: VMContext) =>VMContext & T\n  /**\n   * Provides an initial map to the require cache.\n   * If none is given, it will be initialized to an empty map.\n   */\n  requireCache?: Map<string, Dictionary>\n}\n\n/**\n * A raw VM with a context that can be extended on instantiation. Implements\n * a realm-like interface where one can evaluate code or require CommonJS\n * modules in multiple ways.\n */\nexport class VM<T extends Dictionary> {\n  private readonly requireFn: (referrer: string, specifier: string) => any\n  public readonly requireCache: Map<string, Dictionary>\n  public readonly context: VMContext & T\n\n  constructor(options: VMOptions<T> = {}) {\n    const context = createContext(\n      {},\n      {\n        name: 'Edge Runtime',\n        codeGeneration: options.codeGeneration ?? {\n          strings: false,\n          wasm: true,\n        },\n      }\n    ) as VMContext\n\n    this.requireCache = options.requireCache ?? new Map()\n    this.context = options.extend?.(context) ?? context as VMContext & T\n    this.requireFn = createRequire(this.context, this.requireCache)\n  }\n\n  /**\n   * Allows to run arbitrary code within the VM.\n   */\n  evaluate<T = any>(code: string): T {\n    return runInContext(code, this.context)\n  }\n\n  /**\n   * Allows to require a CommonJS module referenced in the provided file\n   * path within the VM context. It will return its exports.\n   */\n  require<T extends Dictionary = any>(filepath: string): T {\n    return this.requireFn(filepath, filepath)\n  }\n\n  /**\n   * Same as `require` but it will copy each of the exports in the context\n   * of the vm. Then exports can be used inside of the vm with an\n   * evaluated script.\n   */\n  requireInContext<T extends Dictionary = any>(filepath: string): void {\n    const moduleLoaded = this.require<T>(filepath)\n    for (const [key, value] of Object.entries(moduleLoaded)) {\n      this.context[key as keyof typeof this.context] = value\n    }\n  }\n\n  /**\n   * Same as `requireInContext` but allows to pass the code instead of a\n   * reference to a file. It will create a temporary file and then load\n   * it in the VM Context.\n   */\n  requireInlineInContext(code: string): void {\n    const file = tempFile(code)\n    this.requireInContext(file.path)\n    file.remove()\n  }\n}\n\nexport interface VMContext {\n  Array: typeof Array\n  ArrayBuffer: typeof ArrayBuffer\n  Atomics: typeof Atomics\n  BigInt: typeof BigInt\n  BigInt64Array: typeof BigInt64Array\n  BigUint64Array: typeof BigUint64Array\n  Boolean: typeof Boolean\n  DataView: typeof DataView\n  Date: typeof Date\n  decodeURI: typeof decodeURI\n  decodeURIComponent: typeof decodeURIComponent\n  encodeURI: typeof encodeURI\n  encodeURIComponent: typeof encodeURIComponent\n  Error: typeof Error\n  EvalError: typeof EvalError\n  Float32Array: typeof Float32Array\n  Float64Array: typeof Float64Array\n  Function: typeof Function\n  Infinity: typeof Infinity\n  Int8Array: typeof Int8Array\n  Int16Array: typeof Int16Array\n  Int32Array: typeof Int32Array\n  Intl: typeof Intl\n  isFinite: typeof isFinite\n  isNaN: typeof isNaN\n  JSON: typeof JSON\n  Map: typeof Map\n  Math: typeof Math\n  Number: typeof Number\n  Object: typeof Object\n  parseFloat: typeof parseFloat\n  parseInt: typeof parseInt\n  Promise: typeof Promise\n  Proxy: typeof Proxy\n  RangeError: typeof RangeError\n  ReferenceError: typeof ReferenceError\n  Reflect: typeof Reflect\n  RegExp: typeof RegExp\n  Set: typeof Set\n  SharedArrayBuffer: typeof SharedArrayBuffer\n  String: typeof String\n  Symbol: typeof Symbol\n  SyntaxError: typeof SyntaxError\n  TypeError: typeof TypeError\n  Uint8Array: typeof Uint8Array\n  Uint8ClampedArray: typeof Uint8ClampedArray\n  Uint16Array: typeof Uint16Array\n  Uint32Array: typeof Uint32Array\n  URIError: typeof URIError\n  WeakMap: typeof WeakMap\n  WeakSet: typeof WeakSet\n  WebAssembly: typeof WebAssembly\n  [key: string | number]: any\n}\n"]}