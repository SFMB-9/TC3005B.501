{"version":3,"file":"require.js","sourceRoot":"","sources":["../src/require.ts"],"names":[],"mappings":";;;AAEA,2BAAiC;AACjC,2BAAiC;AACjC,+BAA8B;AAE9B;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,MAOnC;IACC,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG,MAAM,CAAA;IACtD,MAAM,SAAS,GAAG,aAAa,CAAC,OAAO,EAAE,YAAY,CAAC,CAAA;IACtD,KAAK,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,YAAY,EAAE;QAC/C,MAAM,GAAG,GAAG,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;QACjC,KAAK,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC5C,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAA;SAC1C;KACF;AACH,CAAC;AAhBD,kDAgBC;AAED,SAAgB,aAAa,CAC3B,OAAgB,EAChB,KAAuB,EACvB,UAAwB,EACxB,gBAAkC,EAAE;IAEpC,OAAO,SAAS,SAAS,CAAC,QAAgB,EAAE,SAAiB;QAC3D,MAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE;YAC1C,KAAK,EAAE,CAAC,IAAA,cAAO,EAAC,QAAQ,CAAC,CAAC;SAC3B,CAAC,CAAA;QAEF,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;QAC1D,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,IAAI,EAAE;YAC3C,OAAO,MAAM,CAAC,OAAO,CAAA;SACtB;QAED,MAAM,MAAM,GAAG;YACb,OAAO,EAAE,EAAE;YACX,MAAM,EAAE,KAAK;YACb,EAAE,EAAE,QAAQ;SACb,CAAA;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAA;QAC3B,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,GAAG,CAAC,QAAQ,CAAC,CAAA;QACzB,MAAM,EAAE,GAAG,IAAA,iBAAY,EACrB,yDAAyD,MAAM,CAAC,IAAI,CAClE,aAAa,CACd,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,IAAA,iBAAY,EAAC,QAAQ,EAAE,OAAO,CAAC,MAAM,EACtD,OAAO,CACR,CAAA;QAED,IAAI;YACF,EAAE,CACA,MAAM,EACN,MAAM,CAAC,OAAO,EACd,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,EAC9B,IAAA,cAAO,EAAC,QAAQ,CAAC,EACjB,QAAQ,EACR,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAChC,CAAA;SACF;QAAC,OAAO,KAAK,EAAE;YACd,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;YACtB,MAAM,KAAK,CAAA;SACZ;QACD,MAAM,CAAC,MAAM,GAAG,IAAI,CAAA;QACpB,OAAO,MAAM,CAAC,OAAO,CAAA;IACvB,CAAC,CAAA;AACH,CAAC;AA/CD,sCA+CC;AAED,SAAgB,gBAAgB,CAAC,MAMhC;;IACC,OAAO,aAAa,CAClB,MAAM,CAAC,OAAO,EACd,MAAA,MAAM,CAAC,KAAK,mCAAI,IAAI,GAAG,EAAE,EACzB,MAAM,CAAC,UAAU,EACjB,MAAM,CAAC,aAAa,CACrB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,CAAA;AACxC,CAAC;AAbD,4CAaC","sourcesContent":["import type { Dictionary } from './types'\nimport type { Context } from 'vm'\nimport { readFileSync } from 'fs'\nimport { runInContext } from 'vm'\nimport { dirname } from 'path'\n\n/**\n * Allows to require a series of dependencies provided by their path\n * into a provided module context. It fills and accepts a require\n * cache to ensure each module is loaded once.\n */\nexport function requireDependencies(params: {\n  context: Context\n  requireCache: Map<string, Dictionary>\n  dependencies: Array<{\n    mapExports: { [key: string]: string }\n    path: string\n  }>\n}): void {\n  const { context, requireCache, dependencies } = params\n  const requireFn = createRequire(context, requireCache)\n  for (const { path, mapExports } of dependencies) {\n    const mod = requireFn(path, path)\n    for (const mapKey of Object.keys(mapExports)) {\n      context[mapExports[mapKey]] = mod[mapKey]\n    }\n  }\n}\n\nexport function createRequire(\n  context: Context,\n  cache: Map<string, any>,\n  references?: Set<string>,\n  scopedContext: Record<any, any> = {}\n) {\n  return function requireFn(referrer: string, specifier: string) {\n    const resolved = require.resolve(specifier, {\n      paths: [dirname(referrer)],\n    })\n\n    const cached = cache.get(specifier) || cache.get(resolved)\n    if (cached !== undefined && cached !== null) {\n      return cached.exports\n    }\n\n    const module = {\n      exports: {},\n      loaded: false,\n      id: resolved,\n    }\n\n    cache.set(resolved, module)\n    references?.add(resolved)\n    const fn = runInContext(\n      `(function(module,exports,require,__dirname,__filename,${Object.keys(\n        scopedContext\n      ).join(',')}) {${readFileSync(resolved, 'utf-8')}\\n})`,\n      context\n    )\n\n    try {\n      fn(\n        module,\n        module.exports,\n        requireFn.bind(null, resolved),\n        dirname(resolved),\n        resolved,\n        ...Object.values(scopedContext)\n      )\n    } catch (error) {\n      cache.delete(resolved)\n      throw error\n    }\n    module.loaded = true\n    return module.exports\n  }\n}\n\nexport function requireWithCache(params: {\n  cache?: Map<string, any>\n  context: Context\n  path: string\n  references?: Set<string>\n  scopedContext?: Record<string, any>\n}) {\n  return createRequire(\n    params.context,\n    params.cache ?? new Map(),\n    params.references,\n    params.scopedContext\n  ).call(null, params.path, params.path)\n}\n"]}