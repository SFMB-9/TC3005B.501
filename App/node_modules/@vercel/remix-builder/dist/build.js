"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const ts_morph_1 = require("ts-morph");
const fs_1 = require("fs");
const path_1 = require("path");
const build_utils_1 = require("@vercel/build-utils");
const static_config_1 = require("@vercel/static-config");
const nft_1 = require("@vercel/nft");
const utils_1 = require("./utils");
const semver_1 = __importDefault(require("semver"));
const _require = eval('require');
const REMIX_RUN_DEV_PATH = (0, path_1.dirname)(_require.resolve('@remix-run/dev/package.json'));
const DEFAULTS_PATH = (0, path_1.join)(__dirname, '../defaults');
const edgeServerSrcPromise = fs_1.promises.readFile((0, path_1.join)(DEFAULTS_PATH, 'server-edge.mjs'), 'utf-8');
const nodeServerSrcPromise = fs_1.promises.readFile((0, path_1.join)(DEFAULTS_PATH, 'server-node.mjs'), 'utf-8');
// This value is the minimum supported version for our fork of Remix
const minimumSupportRemixVersion = '1.10.0';
const build = async ({ entrypoint, files, workPath, repoRootPath, config, meta = {}, }) => {
    const { installCommand, buildCommand } = config;
    await (0, build_utils_1.download)(files, workPath, meta);
    const mountpoint = (0, path_1.dirname)(entrypoint);
    const entrypointFsDirname = (0, path_1.join)(workPath, mountpoint);
    // Run "Install Command"
    const nodeVersion = await (0, build_utils_1.getNodeVersion)(entrypointFsDirname, undefined, config, meta);
    const { cliType, packageJsonPath, lockfileVersion } = await (0, build_utils_1.scanParentDirs)(entrypointFsDirname);
    if (!packageJsonPath) {
        throw new Error('Failed to locate `package.json` file in your project');
    }
    const pkgRaw = await fs_1.promises.readFile(packageJsonPath, 'utf8');
    const pkg = JSON.parse(pkgRaw);
    const spawnOpts = (0, build_utils_1.getSpawnOptions)(meta, nodeVersion);
    if (!spawnOpts.env) {
        spawnOpts.env = {};
    }
    spawnOpts.env = (0, build_utils_1.getEnvForPackageManager)({
        cliType,
        lockfileVersion,
        nodeVersion,
        env: spawnOpts.env,
    });
    if (typeof installCommand === 'string') {
        if (installCommand.trim()) {
            console.log(`Running "install" command: \`${installCommand}\`...`);
            await (0, build_utils_1.execCommand)(installCommand, {
                ...spawnOpts,
                cwd: entrypointFsDirname,
            });
        }
        else {
            console.log(`Skipping "install" command...`);
        }
    }
    else {
        await (0, build_utils_1.runNpmInstall)(entrypointFsDirname, [], spawnOpts, meta, nodeVersion);
    }
    // Determine the version of Remix based on the `@remix-run/dev`
    // package version.
    const remixRunDevPath = await ensureResolvable(entrypointFsDirname, repoRootPath, '@remix-run/dev');
    const remixVersion = JSON.parse(await fs_1.promises.readFile((0, path_1.join)(remixRunDevPath, 'package.json'), 'utf8')).version;
    const remixConfig = await (0, utils_1.chdirAndReadConfig)(entrypointFsDirname, packageJsonPath);
    const { serverEntryPoint, appDirectory } = remixConfig;
    const remixRoutes = Object.values(remixConfig.routes);
    // `app/entry.server.tsx` and `app/entry.client.tsx` are optional in Remix,
    // so if either of those files are missing then add our own versions.
    const userEntryServerFile = (0, utils_1.findEntry)(appDirectory, 'entry.server');
    if (!userEntryServerFile) {
        await fs_1.promises.copyFile((0, path_1.join)(DEFAULTS_PATH, 'entry.server.jsx'), (0, path_1.join)(appDirectory, 'entry.server.jsx'));
        if (!pkg.dependencies['@vercel/remix']) {
            // Dependency version resolution logic
            // 1. Users app is on 1.9.0 -> we install the 1.10.0 (minimum) version of our fork (`@vercel/remix`)
            // 2. Users app is on 1.11.0 (a version greater than 1.10.0 and less than the latest version of the fork) -> we install the (matching) 1.11.0 version of `@vercel/remix`
            // 3. Users app is on something greater than our latest version of the fork -> we install the latest version of our fork
            // remixVersion is the version of the `@remix-run/dev` package in the *users' app*
            const usersRemixVersion = semver_1.default.gt(remixVersion, minimumSupportRemixVersion)
                ? remixVersion
                : minimumSupportRemixVersion;
            // Prevent frozen lockfile rejections
            const envForAddDep = { ...spawnOpts.env };
            delete envForAddDep.CI;
            delete envForAddDep.VERCEL;
            delete envForAddDep.NOW_BUILDER;
            await (0, utils_1.addDependency)(cliType, [
                `@vercel/remix@${semver_1.default.gt(usersRemixVersion, require('@remix-run/dev/package.json').version)
                    ? 'latest'
                    : usersRemixVersion}`,
            ], {
                ...spawnOpts,
                env: envForAddDep,
                cwd: entrypointFsDirname,
            });
        }
    }
    const userEntryClientFile = (0, utils_1.findEntry)(remixConfig.appDirectory, 'entry.client');
    if (!userEntryClientFile) {
        await fs_1.promises.copyFile((0, path_1.join)(DEFAULTS_PATH, 'entry.client.react.jsx'), (0, path_1.join)(appDirectory, 'entry.client.jsx'));
    }
    let remixConfigWrapped = false;
    const remixConfigPath = (0, utils_1.findConfig)(entrypointFsDirname, 'remix.config');
    const renamedRemixConfigPath = remixConfigPath
        ? `${remixConfigPath}.original${(0, path_1.extname)(remixConfigPath)}`
        : undefined;
    const backupRemixRunDevPath = `${remixRunDevPath}.__vercel_backup`;
    await fs_1.promises.rename(remixRunDevPath, backupRemixRunDevPath);
    await fs_1.promises.symlink(REMIX_RUN_DEV_PATH, remixRunDevPath);
    // These get populated inside the try/catch below
    let serverBundles;
    const serverBundlesMap = new Map();
    const resolvedConfigsMap = new Map();
    try {
        // Read the `export const config` (if any) for each route
        const project = new ts_morph_1.Project();
        const staticConfigsMap = new Map();
        for (const route of remixRoutes) {
            const routePath = (0, path_1.join)(remixConfig.appDirectory, route.file);
            const staticConfig = (0, static_config_1.getConfig)(project, routePath);
            staticConfigsMap.set(route, staticConfig);
        }
        for (const route of remixRoutes) {
            const config = (0, utils_1.getResolvedRouteConfig)(route, remixConfig.routes, staticConfigsMap);
            resolvedConfigsMap.set(route, config);
        }
        // Figure out which routes belong to which server bundles
        // based on having common static config properties
        for (const route of remixRoutes) {
            if ((0, utils_1.isLayoutRoute)(route.id, remixRoutes))
                continue;
            const config = resolvedConfigsMap.get(route);
            if (!config) {
                throw new Error(`Expected resolved config for "${route.id}"`);
            }
            const hash = (0, utils_1.calculateRouteConfigHash)(config);
            let routesForHash = serverBundlesMap.get(hash);
            if (!Array.isArray(routesForHash)) {
                routesForHash = [];
                serverBundlesMap.set(hash, routesForHash);
            }
            routesForHash.push(route);
        }
        serverBundles = Array.from(serverBundlesMap.entries()).map(([hash, routes]) => {
            const runtime = resolvedConfigsMap.get(routes[0])?.runtime ?? 'nodejs';
            return {
                serverBuildPath: `build/build-${runtime}-${hash}.js`,
                routes: routes.map(r => r.id),
            };
        });
        // We need to patch the `remix.config.js` file to force some values necessary
        // for a build that works on either Node.js or the Edge runtime
        if (remixConfigPath && renamedRemixConfigPath) {
            await fs_1.promises.rename(remixConfigPath, renamedRemixConfigPath);
            // Figure out if the `remix.config` file is using ESM syntax
            let isESM = false;
            try {
                _require(renamedRemixConfigPath);
            }
            catch (err) {
                isESM = err.code === 'ERR_REQUIRE_ESM';
            }
            let patchedConfig;
            if (isESM) {
                patchedConfig = `import config from './${(0, path_1.basename)(renamedRemixConfigPath)}';
config.serverBuildTarget = undefined;
config.serverModuleFormat = 'cjs';
config.serverPlatform = 'node';
config.serverBuildPath = undefined;
config.serverBundles = ${JSON.stringify(serverBundles)};
export default config;`;
            }
            else {
                patchedConfig = `const config = require('./${(0, path_1.basename)(renamedRemixConfigPath)}');
config.serverBuildTarget = undefined;
config.serverModuleFormat = 'cjs';
config.serverPlatform = 'node';
config.serverBuildPath = undefined;
config.serverBundles = ${JSON.stringify(serverBundles)};
module.exports = config;`;
            }
            await fs_1.promises.writeFile(remixConfigPath, patchedConfig);
            remixConfigWrapped = true;
        }
        // Make `remix build` output production mode
        spawnOpts.env.NODE_ENV = 'production';
        // Run "Build Command"
        if (buildCommand) {
            (0, build_utils_1.debug)(`Executing build command "${buildCommand}"`);
            await (0, build_utils_1.execCommand)(buildCommand, {
                ...spawnOpts,
                cwd: entrypointFsDirname,
            });
        }
        else {
            if (hasScript('vercel-build', pkg)) {
                (0, build_utils_1.debug)(`Executing "yarn vercel-build"`);
                await (0, build_utils_1.runPackageJsonScript)(entrypointFsDirname, 'vercel-build', spawnOpts);
            }
            else if (hasScript('build', pkg)) {
                (0, build_utils_1.debug)(`Executing "yarn build"`);
                await (0, build_utils_1.runPackageJsonScript)(entrypointFsDirname, 'build', spawnOpts);
            }
            else {
                await (0, build_utils_1.execCommand)('remix build', {
                    ...spawnOpts,
                    cwd: entrypointFsDirname,
                });
            }
        }
    }
    finally {
        // Clean up our patched `remix.config.js` to be polite
        if (remixConfigWrapped && remixConfigPath && renamedRemixConfigPath) {
            await fs_1.promises.rename(renamedRemixConfigPath, remixConfigPath);
        }
        // Remove `@remix-run/dev` symlink
        await fs_1.promises.unlink(remixRunDevPath);
        await fs_1.promises.rename(backupRemixRunDevPath, remixRunDevPath);
    }
    // This needs to happen before we run NFT to create the Node/Edge functions
    await Promise.all([
        ensureResolvable(entrypointFsDirname, repoRootPath, '@remix-run/server-runtime'),
        ensureResolvable(entrypointFsDirname, repoRootPath, '@remix-run/node'),
    ]);
    const [staticFiles, ...functions] = await Promise.all([
        (0, build_utils_1.glob)('**', (0, path_1.join)(entrypointFsDirname, 'public')),
        ...serverBundles.map(bundle => {
            const firstRoute = remixConfig.routes[bundle.routes[0]];
            const config = resolvedConfigsMap.get(firstRoute) ?? {
                runtime: 'nodejs',
            };
            if (config.runtime === 'edge') {
                return createRenderEdgeFunction(entrypointFsDirname, repoRootPath, (0, path_1.join)(entrypointFsDirname, bundle.serverBuildPath), serverEntryPoint, remixVersion, config);
            }
            return createRenderNodeFunction(nodeVersion, entrypointFsDirname, repoRootPath, (0, path_1.join)(entrypointFsDirname, bundle.serverBuildPath), serverEntryPoint, remixVersion, config);
        }),
    ]);
    const output = staticFiles;
    const routes = [
        {
            src: '^/build/(.*)$',
            headers: { 'cache-control': 'public, max-age=31536000, immutable' },
            continue: true,
        },
        {
            handle: 'filesystem',
        },
    ];
    for (const route of remixRoutes) {
        // Layout routes don't get a function / route added
        if ((0, utils_1.isLayoutRoute)(route.id, remixRoutes))
            continue;
        const { path, rePath } = (0, utils_1.getPathFromRoute)(route, remixConfig.routes);
        // If the route is a pathless layout route (at the root level)
        // and doesn't have any sub-routes, then a function should not be created.
        if (!path) {
            continue;
        }
        const funcIndex = serverBundles.findIndex(bundle => {
            return bundle.routes.includes(route.id);
        });
        const func = functions[funcIndex];
        if (!func) {
            throw new Error(`Could not determine server bundle for "${route.id}"`);
        }
        output[path] =
            func instanceof build_utils_1.EdgeFunction
                ? // `EdgeFunction` currently requires the "name" property to be set.
                    // Ideally this property will be removed, at which point we can
                    // return the same `edgeFunction` instance instead of creating a
                    // new one for each page.
                    new build_utils_1.EdgeFunction({
                        ...func,
                        name: path,
                    })
                : func;
        // If this is a dynamic route then add a Vercel route
        const re = (0, utils_1.getRegExpFromPath)(rePath);
        if (re) {
            routes.push({
                src: re.source,
                dest: path,
            });
        }
    }
    // Add a 404 path for not found pages to be server-side rendered by Remix.
    // Use an edge function bundle if one was generated, otherwise use Node.js.
    if (!output['404']) {
        const edgeFunctionIndex = Array.from(serverBundlesMap.values()).findIndex(routes => {
            const runtime = resolvedConfigsMap.get(routes[0])?.runtime;
            return runtime === 'edge';
        });
        const func = edgeFunctionIndex !== -1 ? functions[edgeFunctionIndex] : functions[0];
        output['404'] =
            func instanceof build_utils_1.EdgeFunction
                ? new build_utils_1.EdgeFunction({ ...func, name: '404' })
                : func;
    }
    routes.push({
        src: '/(.*)',
        dest: '/404',
    });
    return { routes, output, framework: { version: remixVersion } };
};
exports.build = build;
function hasScript(scriptName, pkg) {
    const scripts = (pkg && pkg.scripts) || {};
    return typeof scripts[scriptName] === 'string';
}
async function createRenderNodeFunction(nodeVersion, entrypointDir, rootDir, serverBuildPath, serverEntryPoint, remixVersion, config) {
    const files = {};
    let handler = (0, path_1.relative)(rootDir, serverBuildPath);
    let handlerPath = (0, path_1.join)(rootDir, handler);
    if (!serverEntryPoint) {
        const baseServerBuildPath = (0, path_1.basename)(serverBuildPath, '.js');
        handler = (0, path_1.join)((0, path_1.dirname)(handler), `server-${baseServerBuildPath}.mjs`);
        handlerPath = (0, path_1.join)(rootDir, handler);
        // Copy the `server-node.mjs` file into the "build" directory
        const nodeServerSrc = await nodeServerSrcPromise;
        await writeEntrypointFile(handlerPath, nodeServerSrc.replace('@remix-run/dev/server-build', `./${baseServerBuildPath}.js`), rootDir);
    }
    // Trace the handler with `@vercel/nft`
    const trace = await (0, nft_1.nodeFileTrace)([handlerPath], {
        base: rootDir,
        processCwd: entrypointDir,
    });
    for (const warning of trace.warnings) {
        (0, build_utils_1.debug)(`Warning from trace: ${warning.message}`);
    }
    for (const file of trace.fileList) {
        files[file] = await build_utils_1.FileFsRef.fromFsPath({ fsPath: (0, path_1.join)(rootDir, file) });
    }
    const fn = new build_utils_1.NodejsLambda({
        files,
        handler,
        runtime: nodeVersion.runtime,
        shouldAddHelpers: false,
        shouldAddSourcemapSupport: false,
        operationType: 'SSR',
        supportsResponseStreaming: true,
        regions: config.regions,
        memory: config.memory,
        maxDuration: config.maxDuration,
        framework: {
            slug: 'remix',
            version: remixVersion,
        },
    });
    return fn;
}
async function createRenderEdgeFunction(entrypointDir, rootDir, serverBuildPath, serverEntryPoint, remixVersion, config) {
    const files = {};
    let handler = (0, path_1.relative)(rootDir, serverBuildPath);
    let handlerPath = (0, path_1.join)(rootDir, handler);
    if (!serverEntryPoint) {
        const baseServerBuildPath = (0, path_1.basename)(serverBuildPath, '.js');
        handler = (0, path_1.join)((0, path_1.dirname)(handler), `server-${baseServerBuildPath}.mjs`);
        handlerPath = (0, path_1.join)(rootDir, handler);
        // Copy the `server-edge.mjs` file into the "build" directory
        const edgeServerSrc = await edgeServerSrcPromise;
        await writeEntrypointFile(handlerPath, edgeServerSrc.replace('@remix-run/dev/server-build', `./${baseServerBuildPath}.js`), rootDir);
    }
    let remixRunVercelPkgJson;
    // Trace the handler with `@vercel/nft`
    const trace = await (0, nft_1.nodeFileTrace)([handlerPath], {
        base: rootDir,
        processCwd: entrypointDir,
        conditions: ['edge-light', 'browser', 'module', 'import', 'require'],
        async readFile(fsPath) {
            let source;
            try {
                source = await fs_1.promises.readFile(fsPath);
            }
            catch (err) {
                if (err.code === 'ENOENT' || err.code === 'EISDIR') {
                    return null;
                }
                throw err;
            }
            if ((0, path_1.basename)(fsPath) === 'package.json') {
                // For Edge Functions, patch "main" field to prefer "browser" or "module"
                const pkgJson = JSON.parse(source.toString());
                // When `@remix-run/vercel` is detected, we need to modify the `package.json`
                // to include the "browser" field so that the proper Edge entrypoint file
                // is used. This is a temporary stop gap until this PR is merged:
                // https://github.com/remix-run/remix/pull/5537
                if (pkgJson.name === '@remix-run/vercel') {
                    pkgJson.browser = 'dist/edge.js';
                    pkgJson.dependencies['@remix-run/server-runtime'] =
                        pkgJson.dependencies['@remix-run/node'];
                    if (!remixRunVercelPkgJson) {
                        remixRunVercelPkgJson = JSON.stringify(pkgJson, null, 2) + '\n';
                        // Copy in the edge entrypoint so that NFT can properly resolve it
                        const vercelEdgeEntrypointPath = (0, path_1.join)(DEFAULTS_PATH, 'vercel-edge-entrypoint.js');
                        const vercelEdgeEntrypointDest = (0, path_1.join)((0, path_1.dirname)(fsPath), 'dist/edge.js');
                        await fs_1.promises.copyFile(vercelEdgeEntrypointPath, vercelEdgeEntrypointDest);
                    }
                }
                for (const prop of ['browser', 'module']) {
                    const val = pkgJson[prop];
                    if (typeof val === 'string') {
                        pkgJson.main = val;
                        // Return the modified `package.json` to nft
                        source = JSON.stringify(pkgJson);
                        break;
                    }
                }
            }
            return source;
        },
    });
    for (const warning of trace.warnings) {
        (0, build_utils_1.debug)(`Warning from trace: ${warning.message}`);
    }
    for (const file of trace.fileList) {
        if (remixRunVercelPkgJson &&
            file.endsWith(`@remix-run${path_1.sep}vercel${path_1.sep}package.json`)) {
            // Use the modified `@remix-run/vercel` package.json which contains "browser" field
            files[file] = new build_utils_1.FileBlob({ data: remixRunVercelPkgJson });
        }
        else {
            files[file] = await build_utils_1.FileFsRef.fromFsPath({ fsPath: (0, path_1.join)(rootDir, file) });
        }
    }
    const fn = new build_utils_1.EdgeFunction({
        files,
        deploymentTarget: 'v8-worker',
        name: 'render',
        entrypoint: handler,
        regions: config.regions,
        framework: {
            slug: 'remix',
            version: remixVersion,
        },
    });
    return fn;
}
async function ensureResolvable(start, base, pkgName) {
    try {
        const resolvedPkgPath = _require.resolve(`${pkgName}/package.json`, {
            paths: [start],
        });
        const resolvedPath = (0, path_1.dirname)(resolvedPkgPath);
        if (!(0, path_1.relative)(base, resolvedPath).startsWith(`..${path_1.sep}`)) {
            // Resolved path is within the root of the project, so all good
            (0, build_utils_1.debug)(`"${pkgName}" resolved to '${resolvedPath}'`);
            return resolvedPath;
        }
    }
    catch (err) {
        if (err.code !== 'MODULE_NOT_FOUND') {
            throw err;
        }
    }
    // If we got to here then `pkgName` was not resolvable up to the root
    // of the project. Try a couple symlink tricks, otherwise we'll bail.
    // Attempt to find the package in `node_modules/.pnpm` (pnpm)
    const pnpmDir = await (0, build_utils_1.walkParentDirs)({
        base,
        start,
        filename: 'node_modules/.pnpm',
    });
    if (pnpmDir) {
        const prefix = `${pkgName.replace('/', '+')}@`;
        const packages = await fs_1.promises.readdir(pnpmDir);
        const match = packages.find(p => p.startsWith(prefix));
        if (match) {
            const pkgDir = (0, path_1.join)(pnpmDir, match, 'node_modules', pkgName);
            await ensureSymlink(pkgDir, (0, path_1.join)(pnpmDir, '..'), pkgName);
            return pkgDir;
        }
    }
    // Attempt to find the package in `node_modules/.store` (npm 9+ linked mode)
    const npmDir = await (0, build_utils_1.walkParentDirs)({
        base,
        start,
        filename: 'node_modules/.store',
    });
    if (npmDir) {
        const prefix = `${(0, path_1.basename)(pkgName)}@`;
        const prefixDir = (0, path_1.join)(npmDir, (0, path_1.dirname)(pkgName));
        const packages = await fs_1.promises.readdir(prefixDir);
        const match = packages.find(p => p.startsWith(prefix));
        if (match) {
            const pkgDir = (0, path_1.join)(prefixDir, match, 'node_modules', pkgName);
            await ensureSymlink(pkgDir, (0, path_1.join)(npmDir, '..'), pkgName);
            return pkgDir;
        }
    }
    throw new Error(`Failed to resolve "${pkgName}". To fix this error, add "${pkgName}" to "dependencies" in your \`package.json\` file.`);
}
async function ensureSymlink(target, nodeModulesDir, pkgName) {
    const symlinkPath = (0, path_1.join)(nodeModulesDir, pkgName);
    const symlinkDir = (0, path_1.dirname)(symlinkPath);
    const relativeTarget = (0, path_1.relative)(symlinkDir, target);
    try {
        const existingTarget = await fs_1.promises.readlink(symlinkPath);
        if (existingTarget === relativeTarget) {
            // Symlink is already the expected value, so do nothing
            return;
        }
        else {
            // If a symlink already exists then delete it if the target doesn't match
            await fs_1.promises.unlink(symlinkPath);
        }
    }
    catch (err) {
        // Ignore when path does not exist or is not a symlink
        if (err.code !== 'ENOENT' && err.code !== 'EINVAL') {
            throw err;
        }
    }
    await fs_1.promises.symlink(relativeTarget, symlinkPath);
    (0, build_utils_1.debug)(`Created symlink for "${pkgName}"`);
}
async function writeEntrypointFile(path, data, rootDir) {
    try {
        await fs_1.promises.writeFile(path, data);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error(`The "${(0, path_1.relative)(rootDir, (0, path_1.dirname)(path))}" directory does not exist. Please contact support@vercel.com.`);
        }
        throw err;
    }
}
//# sourceMappingURL=build.js.map